{"kernelspec":{"display_name":"Anaconda (Python 3)","language":"python","name":"anaconda3"},"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.5.2"}}
{"cell_type":"code","execution_count":22,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::a1ea3bf0-d980-4902-bf70-b0f349343ceb","text/plain":"<matplotlib.figure.Figure at 0x7fe8d6681320>"},"metadata":{},"output_type":"display_data"}],"source":"from PIL import Image\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load the images.\norig_img = Image.open(\"alanturing.png\")\norig_img = orig_img.convert('L')\ncorr_img = Image.open(\"alanturing-blabla.png\")\ncorr_img = corr_img.convert('L')\n\n# Convert to arrays.\nUorig = np.array(orig_img)\nUcorr = np.array(corr_img)\nrows, cols = Uorig.shape\n\n# Known is 1 if the pixel is known,\n# 0 if the pixel was corrupted.\nKnown = np.zeros((rows, cols))\nfor i in range(rows):\n    for j in range(cols):\n         if Uorig[i, j] == Ucorr[i, j]:\n            Known[i, j] = 1\n\n%matplotlib inline\nfig, ax = plt.subplots(1, 2,figsize=(10, 5))\nax[0].imshow(orig_img);\nax[0].set_title(\"Original Image\")\nax[0].axis('off')\nax[1].imshow(corr_img);\nax[1].set_title(\"Corrupted Image\")\nax[1].axis('off');"}
{"cell_type":"code","execution_count":23,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::af3473ef-71d3-4408-8f5d-bc1e15ebd70f","text/plain":"<PIL.Image.Image image mode=L size=600x400 at 0x7FE8D66E3D30>"},"execution_count":23,"metadata":{},"output_type":"execute_result"}],"source":"orig_img"}
{"cell_type":"code","execution_count":24,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"import cvxpy as cvx"}
{"cell_type":"code","execution_count":25,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"----------------------------------------------------------------------------\n\tSCS v1.2.6 - Splitting Conic Solver\n\t(c) Brendan O'Donoghue, Stanford University, 2012-2016\n----------------------------------------------------------------------------\nLin-sys: sparse-indirect, nnz in A = 1417549, CG tol ~ 1/iter^(2.00)\neps = 1.00e-03, alpha = 1.50, max_iters = 2500, normalize = 1, scale = 1.00\nVariables n = 479001, constraints m = 957003\nCones:\tprimal zero / dual free vars: 240000\n\tsoc vars: 717003, soc blks: 239001\nSetup time: 1.79e-01s\n----------------------------------------------------------------------------\n Iter | pri res | dua res | rel gap | pri obj | dua obj | kap/tau | time (s)\n----------------------------------------------------------------------------\n     0| 5.32e+00  4.92e+00  1.00e+00 -1.26e+08  8.33e+06  0.00e+00  1.15e+00 \n   100| 2.90e-03  9.75e-04  1.40e-03  4.55e+06  4.56e+06  3.72e-09  1.93e+01 \n   200| 1.02e-03  2.64e-04  3.47e-04  4.58e+06  4.58e+06  3.79e-09  3.81e+01 \n   220| 8.50e-04  2.31e-04  2.65e-04  4.58e+06  4.58e+06  3.80e-09  4.18e+01 \n----------------------------------------------------------------------------\nStatus: Solved\nTiming: Solve time: 4.18e+01s\n\tLin-sys: avg # CG iterations: 8.81, avg solve time: 1.58e-01s\n\tCones: avg projection time: 4.17e-03s\n----------------------------------------------------------------------------\nError metrics:\ndist(s, K) = 5.6843e-14, dist(y, K*) = 2.2204e-16, s'y/|s||y| = 8.6617e-18\n|Ax + s - b|_2 / (1 + |b|_2) = 8.5005e-04\n|A'y + c|_2 / (1 + |c|_2) = 2.3101e-04\n|c'x + b'y| / (1 + |c'x| + |b'y|) = 2.6502e-04\n----------------------------------------------------------------------------\nc'x = 4576651.7151, -b'y = 4579078.1252\n============================================================================\n"},{"data":{"text/plain":"4576651.715057738"},"execution_count":25,"metadata":{},"output_type":"execute_result"}],"source":"U = cvx.Variable(rows, cols)\nobj = cvx.Minimize(cvx.tv(U))\nconstraints = [cvx.mul_elemwise(Known, U) == cvx.mul_elemwise(Known, Ucorr)]\nprob = cvx.Problem(obj, constraints)\n\nprob.solve(verbose=True, solver=cvx.SCS)"}
{"cell_type":"code","execution_count":26,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/plain":"(-0.5, 599.5, 399.5, -0.5)"},"execution_count":26,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::f26294d9-fabf-4e20-b193-1fd8c099ccea","text/plain":"<matplotlib.figure.Figure at 0x7fe883ce2668>"},"metadata":{},"output_type":"display_data"}],"source":"fig, ax = plt.subplots(1, 2, figsize=(10,5))\nimg_rec = Image.fromarray(U.value)\nax[0].imshow(img_rec);\nax[0].set_title(\"In-Painted Image\")\nax[0].axis('off')\n\nimg_diff = Image.fromarray(10*np.abs(Uorig - U.value))\nax[1].imshow(img_diff);\nax[1].set_title(\"Difference Image\")\nax[1].axis('off')"}
{"cell_type":"code","execution_count":30,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x7fe8836df940>"},"execution_count":30,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::f151f263-56dc-49a5-9d31-ec22a60d531e","text/plain":"<matplotlib.figure.Figure at 0x7fe8836eaf60>"},"metadata":{},"output_type":"display_data"}],"source":"plt.imshow(img_rec)"}
{"cell_type":"code","execution_count":3,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::5a604c4e-957c-461f-b132-1b69d311f7c5","text/plain":"<matplotlib.figure.Figure at 0x7fb940cfd0f0>"},"metadata":{},"output_type":"display_data"}],"source":"from PIL import Image\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load the image using the PIL package and transform to grayscale\nim1 = Image.open(\"alanturing.png\")\ngrim1 = im1.convert('L')\n\n# Transform into numpy array and get parameters\nimarray1 = np.array(grim1, np.float64)\nrows, cols = imarray1.shape\n\n# Create an image wh\ndiffs1 = np.zeros((rows-1, cols-1))\nfor i in range(rows-1):\n    for j in range(cols-1):\n        diffs1[i,j] = np.sqrt((imarray1[i+1,j]-imarray1[i,j])**2 + (imarray1[i,j+1]-imarray1[i,j])**2)\n\n# Load the image using the PIL package and transform to grayscale\nim2 = Image.open(\"alanturing-blabla.png\")\ngrim2 = im2.convert('L')\n\n# Transform into numpy array and get parameters\nimarray2 = np.array(grim2, np.float64)\nrows, cols = imarray2.shape\n\n# Create an image wh\ndiffs2 = np.zeros((rows-1, cols-1))\nfor i in range(rows-1):\n    for j in range(cols-1):\n        diffs2[i,j] = np.sqrt((imarray2[i+1,j]-imarray2[i,j])**2 + (imarray2[i,j+1]-imarray2[i,j])**2)\n\n%matplotlib inline\nfig, ax = plt.subplots(2, 2,figsize=(10, 5))\n\nax[0,0].imshow(im1);\nax[0,0].set_title(r'Original image, $\\|U\\|_{\\mathrm{TV}} = 4819899$')\nax[0,0].axis('off')\n\nax[0,1].imshow(diffs1);\nax[0,1].set_title(\"Differences\")\nax[0,1].axis('off');\n\nax[1,0].imshow(im2);\nax[1,0].set_title(r'Corrupted image, $\\|U\\|_{\\mathrm{TV}} = 6378417$')\nax[1,0].axis('off')\n\nax[1,1].imshow(diffs2);\nax[1,1].set_title(\"Differences\")\nax[1,1].axis('off');\n\nfig.savefig('alanturing-tv.png')"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":""}